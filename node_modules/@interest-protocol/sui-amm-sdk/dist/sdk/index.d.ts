import { JsonRpcProvider, TransactionBlock } from '@mysten/sui.js';
import { Network, Pool } from '../constants/index.js';
import { Address, DexMarket } from '../types.js';
import { AddLiquidityArgs, CreatePoolArgs, FindPoolIdArgs, QuoteAddLiquidityArgs, QuoteRemoveLiquidityArgs, QuoteSwapArgs, QuoteSwapReturn, RemoveLiquidityArgs, SwapArgs } from './sdk.types';
export declare class SDK {
    #private;
    readonly provider: JsonRpcProvider;
    readonly network: Network;
    constructor(provider: JsonRpcProvider, network: Network);
    /**
     * @description It returns the pool object id from a set of two ordered coin types If it returns null, it means the pool is not deployed.
     * @param tokenAType The coin A in Pool<A, B>
     * @param tokenBType The coin B in Pool<A,B>
     * @param account The caller account, it will default to @0x0 if not passed
     */
    findPoolId({ tokenAType, tokenBType, stable, account, }: FindPoolIdArgs): Promise<Address | null>;
    /**
     * @description It returns a {TransactionBlock} to be called
     * @param txb The {TransactionBlock} that will be returned
     * @param coinA An ObjectTransactionArgument of Coin0 on Pool<0,1>
     * @param coinB An ObjectTransactionArgument of Coin1 on Pool<0,1>
     * @param coinAAmount The desired value to add for coin0
     * @param coinBAmount The desired value to add for coin1
     * @param coinAType The type of Coin0
     * @param coinBType The type of Coin1
     * @return txb {TransactionBlock}
     */
    createVolatilePool({ txb, coinAList, coinBList, coinAAmount, coinBAmount, coinAType, coinBType, }: CreatePoolArgs): TransactionBlock;
    /**
     * @description It returns a {TransactionBlock} to be called
     * @param txb The {TransactionBlock} that will be returned
     * @param coinA An ObjectTransactionArgument of Coin0 on Pool<0,1>
     * @param coinB An ObjectTransactionArgument of Coin1 on Pool<0,1>
     * @param coinAAmount The desired value to add for coin0
     * @param coinBAmount The desired value to add for coin1
     * @param coinAType The type of Coin0
     * @param coinBType The type of Coin1
     * @return txb {TransactionBlock}
     */
    createStablePool({ txb, coinAList, coinBList, coinAAmount, coinBAmount, coinAType, coinBType, }: CreatePoolArgs): Promise<TransactionBlock>;
    /**
     * @param txb The {TransactionBlock} class to chain
     * @param coinInList An Array of objects being sold Coin
     * @param coinInAmount The amount of the coin being sold
     * @param coinInType The type of the coin being sold
     * @param coinOutType The type of the coin being bought
     * @param coinOutMinimumAmount The minimum amount to receive in coinOutType to control slippage
     * @param useCache It defaults to false. If it is false, we will first fetch the latest pools data. If not, we will use a cache.
     * @param deadline 30 represents 30 minutes. The TX will be cancelled if not processed within the deadline
     * @param dexMarkets An object of Pools
     */
    swap({ txb, coinInList, coinInAmount, coinInType, coinOutType, coinOutMinimumAmount, useCache, dexMarkets, deadline, }: SwapArgs): Promise<TransactionBlock>;
    /**
     * @description It returns the amount of the coinOutType from swapping the amount of coin type in
     * @param coinInAmount The amount of the coin being sold
     * @param coinInType The type of the coin being sold
     * @param coinOutType The type of the coin being bought
     * @param baseTokens An array of base coins to use for the one hop swap
     * @param useCache It defaults to false. If it is false, we will first fetch the latest pools data. If not, we will use a cache.
     * @param markets An object of Pools
     */
    quoteSwap({ coinInAmount, coinInType, coinOutType, baseTokens, useCache, markets, }: QuoteSwapArgs): Promise<QuoteSwapReturn | null>;
    /**
     * @description It allows a user to add liquidity to a pool. Please note that the coins do not need to be ordered
     * @param txb The {TransactionBlock} class to chain
     * @param stable it determines if the liquidity will be added to a stable or volatile pool
     * @param coinAType The type of the first Coin Pair to be added
     * @param coinBType The type of the second Coin Pair to be added
     * @param coinAList An array of objects of coin0Type
     * @param coinBList An array of objects of coin1Type
     * @param coinAAmount The desired amount of coin0Type to add
     * @param coinBAmount The desired amount of coin1Type to add
     * @param lpCoinMinOut The minimum amount of LpCoins to receive from adding liquidity
     */
    addLiquidity({ txb, stable, coinAType, coinBType, coinAList, coinBList, coinAAmount, coinBAmount, lpCoinMinOut, }: AddLiquidityArgs): TransactionBlock;
    /**
     * @description It allows the caller to calculate how many LpCoins he will receive. The coins must be ordered.
     * @param coin0Type The A type in Pool<A, B>
     * @param coin1Type The B type in Pool<A, B>
     * @param coin0Amount The amount of Coin<A> being deposited
     * @param coin1Amount The amount of Coin<B> being deposited
     * @param stable It indicates if the caller wishes to deposit in a Volatile or Stable Pool
     */
    quoteAddLiquidity({ coin0Type, coin1Type, coin0Amount, coin1Amount, stable, }: QuoteAddLiquidityArgs): Promise<[string, string, string] | null>;
    /**
     * @description It removes liquidity from a pool. Please note that the types do not need to be ordered.
     * @param txb The {TransactionBlock} class to chain
     * @param stable It indicates if the user wishes to remove from a stable or volatile pool
     * @param coin0Type The first coin of the pool
     * @param coinBType The second coin of the pool
     * @param lpCoinList An array of lpCoin objects to be burned to remove the underlying
     * @param lpCoinAmount The desired amount of LP amount to add
     * @param coinAMinAmount The minimum amount of Coin<A> that the user wishes to receive
     * @param coinBMinAmount The minimum amount of Coin<B> that the user wishes to receive
     */
    removeLiquidity({ txb, stable, coinAType, coinBType, lpCoinList, lpCoinAmount, coinAMinAmount, coinBMinAmount, }: RemoveLiquidityArgs): TransactionBlock;
    /**
     * @description It returns the amount of underlying Coins a user will receive by burning LPCoins. The coins must be ordered.
     * @param coin0Type It represents one of the Coin types from a pool
     * @param coin1Type It represents the other Coin type from a pool
     * @param stable It indicates if it is withdrawing from a stable or volatile pool
     * @param lpCoinAmount The minimum amount of Lp Coin objects of LPCoin<CoinAType, CoinBType> to receive
     */
    quoteRemoveLiquidity({ coin0Type, coin1Type, stable, lpCoinAmount, }: QuoteRemoveLiquidityArgs): Promise<null | [string, string]>;
    /**
     * @description The coin types do not need to be ordered. The SDK does not know every single pool in the DEX
     * @param coinAType
     * @param coinBType
     */
    getSortedPoolCoins(coinAType: string, coinBType: string): {
        coinXType: string;
        coinYType: string;
    } | null;
    /**
     * @description It returns the cached Markets [coinAType][coinBType] PoolType
     */
    getCachedMarkets(): DexMarket;
    /**
     * @description It returns a pool object from a Pool Object Id
     * @param poolObjectId The id of Pool object
     */
    getPool(poolObjectId: string): Promise<Pool>;
    getLatestDEXMarkets(): Promise<DexMarket>;
}
